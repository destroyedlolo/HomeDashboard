#!../Selene/Selene --dfb:quiet,no-vt
-- HomeDashBoard, Selenite version
--
-- This tool is configured for my own usage and is matching my home configuration
-- but it should be took as example to build your own dashboard

-- compatibility with newer Lua
local unpack = unpack or table.unpack

-- Hide console's cursor
local f=io.open('/sys/class/graphics/fbcon/cursor_blink', 'w')
if f then	-- working only using root access
	f:write('0')
	f:close()
end

-- Ensure we're not using obsolete version
assert( SELENE_VERSION >= 0.0400, "HDB requires at least Selene v0.04.00" )

-- Load configuration files
require (SELENE_SCRIPT_DIR .. "/LocalConfig")
require (SELENE_SCRIPT_DIR .. "/Colors")

-- Init the screen
Selene.init( Selene.CooperativeConst('FULLSCREEN') )
psrf = SelSurface.create { caps=SelSurface.CapabilityConst('PRIMARY') } -- create a primary surface
psrf:Clear( unpack(COL_BLACK) )

require (SELENE_SCRIPT_DIR .. "/Design")

-- Collection for graphics
dt_pwr = SelCollection.create( srf_tpwrgfx:GetWidth()/5 )
dt_conso = SelCollection.create( srf_consogfx:GetWidth() )

-- Broker's stuffs
local Brk, err = SelMQTT.connect( MQTT_URL, { reliable=false, clientID=MQTT_ClientID } )

function rcvVal( topic, val )
	SelShared.set(topic, val)
	return true
end

function updateVlt()
	upddata( srf_tension, fdigit, SelShared.get('onduleur/input.voltage') .. ' V')
end

function updateConso()
	local cols = {
		[500] = COL_DIGIT,
		[1500] = COL_ORANGE,
		[4500] = COL_RED
	}
	local v = SelShared.get('TeleInfo/Consommation/values/PAPP')
	srf_consommation:SetColor( findgradiancolor(v, cols ) )
	upddata( srf_consommation, fdigit, v .. ' VA')

	dt_conso:Push(v)
	local min,max = dt_conso:MinMax()
	upddata( srf_maxconso, fsdigit, max )
	updgfx( srf_consogfx, dt_conso, 0 )
end

function updateProduction()
	upddata( srf_production, fdigit, SelShared.get('TeleInfo/Production/values/PAPP') .. ' VA')
end

function updateTGN()
	upddata( srf_TGN, fdigit, SelShared.get('maison/Temperature/Grenier Nord') .. "°C" )
end

function updateTChJ()
	upddata( srf_TChJ, fdigit, SelShared.get('maison/Temperature/Chambre Joris') .. "°C" )
end

function updateTSalon()
	local v = SelShared.get('maison/Temperature/Salon')
	srf_TSalon:SetColor( findgradiancolor(v, cols_temperature ) )

	upddata( srf_TSalon, fdigit, v .. "°C" )
end

function updateTBureau()
	upddata( srf_TBureau, fdigit, SelShared.get('maison/Temperature/Bureau') .. "°C" )
end

function updateTDehors()
	upddata( srf_TDehors, fdigit, SelShared.get('maison/Temperature/Dehors') .. "°C" )
end

function updateTCave()
	upddata( srf_TCave, fdigit, SelShared.get('maison/Temperature/Cave') .. "°C" )
end

function updateUPSLd()
	local maxp = tonumber( SelShared.get('onduleur/ups.realpower.nominal') )
	if maxp then -- maximum power not known yet
		upddata( srf_consoUPS, ftitle1, string.format('%3.1f', SelShared.get('onduleur/ups.load')*maxp/100) .. ' W')
	else
		upddata( srf_consoUPS, ftitle1, SelShared.get('onduleur/ups.load') .. ' %')
	end
	local pw = bar_ups.w * SelShared.get('onduleur/ups.load') / 100
	psrf:SetColor( unpack( COL_WHITE ) )
	psrf:FillRectangle( bar_ups.x, bar_ups.y, pw, bar_ups.h )
	psrf:SetColor( unpack( COL_BLACK ) )
	psrf:FillRectangle( bar_ups.x+pw, bar_ups.y, bar_ups.w-pw, bar_ups.h )
end

function updateInternet()
	local intDn = tonumber( SelShared.get('Freebox/DownloadATM') )
	local intUp = tonumber( SelShared.get('Freebox/UploadATM') )
	if intDn and intUp then
		upddata( srf_Internet, ftitle1, intDn .. ' Kb / ' .. intUp ..' Kb' )
	end
end

function updatedWAN()
	local intDn = tonumber( SelShared.get('Freebox/DownloadATM') )
	local wanDn = tonumber( SelShared.get('Freebox/DownloadWAN') )
	if intDn then
		local pw = bar_Idn.w * wanDn * 8 / intDn
		psrf:SetColor( unpack( COL_WHITE ) )
		psrf:FillRectangle( bar_Idn.x, bar_Idn.y, pw, bar_Idn.h )
		psrf:SetColor( unpack( COL_BLACK ) )
		psrf:FillRectangle( bar_Idn.x+pw, bar_Idn.y, bar_Idn.w-pw, bar_Idn.h )
	end
end

function updateuWAN()
	local intUp = tonumber( SelShared.get('Freebox/UploadATM') )
	local wanUp = tonumber( SelShared.get('Freebox/UploadWAN') )
	if intUp then
		local pw = bar_Iup.w * wanUp * 8 / intUp
		psrf:SetColor( unpack( COL_WHITE ) )
		psrf:FillRectangle( bar_Iup.x, bar_Iup.y, pw, bar_Iup.h )
		psrf:SetColor( unpack( COL_BLACK ) )
		psrf:FillRectangle( bar_Iup.x+pw, bar_Iup.y, bar_Iup.w-pw, bar_Iup.h )
	end
end

function updated0Icn()
	updmeteo( 1, SelShared.get('Meteo/Nonglard/0/weather/code' ) )
end

function updated0time()
	local t=os.date("*t", SelShared.get('Meteo/Nonglard/0/time') )
	upddata(srf_MeteoDate[1], fsdigit, t.day ..'/'.. t.month)
end

function updated0tmax()
	local v=SelShared.get('Meteo/Nonglard/0/temperature/day')
	srf_MeteoTMax[1]:SetColor( findgradiancolor(v, cols_temperature ) )
	upddata(srf_MeteoTMax[1], fsdigit, v .. '°C')
end

function updated1Icn()
	updmeteo( 2, SelShared.get('Meteo/Nonglard/1/weather/code' ) )
end

function updated1time()
	local t=os.date("*t", SelShared.get('Meteo/Nonglard/1/time') )
	upddata(srf_MeteoDate[2], fsdigit, t.day ..'/'.. t.month)	
end

function updated1tmax()
	local v=SelShared.get('Meteo/Nonglard/1/temperature/day')
	srf_MeteoTMax[2]:SetColor( findgradiancolor(v, cols_temperature ) )
	upddata(srf_MeteoTMax[2], fsdigit, v .. '°C')
end

function updated2Icn()
	updmeteo( 3, SelShared.get('Meteo/Nonglard/2/weather/code' ) )
end

function updated2time()
	local t=os.date("*t", SelShared.get('Meteo/Nonglard/2/time') )
	upddata(srf_MeteoDate[3], fsdigit, t.day ..'/'.. t.month)	
end

function updated2tmax()
	local v=SelShared.get('Meteo/Nonglard/2/temperature/day')
	srf_MeteoTMax[3]:SetColor( findgradiancolor(v, cols_temperature ) )
	upddata(srf_MeteoTMax[3], fsdigit, v .. '°C')
end

function updated3Icn()
	updmeteo( 4, SelShared.get('Meteo/Nonglard/3/weather/code' ) )
end

function updated3tmax()
	local v=SelShared.get('Meteo/Nonglard/3/temperature/day')
	srf_MeteoTMax[4]:SetColor( findgradiancolor(v, cols_temperature ) )
	upddata(srf_MeteoTMax[4], fsdigit, v .. '°C')
end

function updated3time()
	local t=os.date("*t", SelShared.get('Meteo/Nonglard/3/time') )
	upddata(srf_MeteoDate[4], fsdigit, t.day ..'/'.. t.month)	
end

function updated4Icn()
	updmeteo( 5, SelShared.get('Meteo/Nonglard/4/weather/code' ) )
end

function updated4time()
	local t=os.date("*t", SelShared.get('Meteo/Nonglard/4/time') )
	upddata(srf_MeteoDate[5], fsdigit, t.day ..'/'.. t.month)	
end

function updated4tmax()
	local v=SelShared.get('Meteo/Nonglard/4/temperature/day')
	srf_MeteoTMax[5]:SetColor( findgradiancolor(v, cols_temperature ) )
	upddata(srf_MeteoTMax[5], fsdigit, v .. '°C')
end

_, err = Brk:subscribe({
	{ topic = "Meteo/Nonglard/0/weather/code", trigger=updated0Icn, trigger_once=true },
	{ topic = "Meteo/Nonglard/1/weather/code", trigger=updated1Icn, trigger_once=true },
	{ topic = "Meteo/Nonglard/2/weather/code", trigger=updated2Icn, trigger_once=true },
	{ topic = "Meteo/Nonglard/3/weather/code", trigger=updated3Icn, trigger_once=true },
	{ topic = "Meteo/Nonglard/4/weather/code", trigger=updated4Icn, trigger_once=true },
	{ topic = "Meteo/Nonglard/0/time", trigger=updated0time, trigger_once=true },
	{ topic = "Meteo/Nonglard/1/time", trigger=updated1time, trigger_once=true },
	{ topic = "Meteo/Nonglard/2/time", trigger=updated2time, trigger_once=true },
	{ topic = "Meteo/Nonglard/3/time", trigger=updated3time, trigger_once=true },
	{ topic = "Meteo/Nonglard/4/time", trigger=updated4time, trigger_once=true },
	{ topic = "Meteo/Nonglard/0/temperature/day", trigger=updated0tmax, trigger_once=true },
	{ topic = "Meteo/Nonglard/1/temperature/day", trigger=updated1tmax, trigger_once=true },
	{ topic = "Meteo/Nonglard/2/temperature/day", trigger=updated2tmax, trigger_once=true },
	{ topic = "Meteo/Nonglard/3/temperature/day", trigger=updated3tmax, trigger_once=true },
	{ topic = "Meteo/Nonglard/4/temperature/day", trigger=updated4tmax, trigger_once=true },
	{ topic = "Freebox/DownloadWAN", trigger=updatedWAN, trigger_once=true },
	{ topic = "Freebox/UploadWAN", trigger=updateuWAN, trigger_once=true },
	{ topic = "Freebox/DownloadATM", func=rcvVal },
	{ topic = "Freebox/UploadATM", trigger=updateInternet, trigger_once=true },
	{ topic = "onduleur/ups.realpower.nominal", func=rcvVal },
	{ topic = "onduleur/ups.load", trigger=updateUPSLd, trigger_once=true },
	{ topic = "maison/Temperature/Grenier Nord", trigger=updateTGN, trigger_once=true },
	{ topic = "maison/Temperature/Chambre Joris", trigger=updateTChJ, trigger_once=true },
	{ topic = "maison/Temperature/Salon", trigger=updateTSalon, trigger_once=true },
	{ topic = "maison/Temperature/Bureau", trigger=updateTBureau, trigger_once=true },
	{ topic = "maison/Temperature/Dehors", trigger=updateTDehors, trigger_once=true },
	{ topic = "maison/Temperature/Cave", trigger=updateTCave, trigger_once=true },
	{ topic = "onduleur/input.voltage", trigger=updateVlt, trigger_once=true },
	{ topic = "TeleInfo/Consommation/values/PAPP", trigger=updateConso, trigger_once=true },
	{ topic = "TeleInfo/Production/values/PAPP", trigger=updateProduction, trigger_once=true }
})

if err then
	print( err )
	return
end

-- Timer for tablet figures
function updateTablet()
	local cols = {
		[1.5] = COL_GREEN,
		[2.75] = COL_ORANGE,
		[4] = COL_RED
	}

	local f = io.open( "/sys/devices/platform/sunxi-i2c.0/i2c-0/0-0034/axp20-supplyer.28/power_supply/ac/voltage_now" )
	local v = f:read('*number') / 1000000
	f:close()
	f = io.open( "/sys/devices/platform/sunxi-i2c.0/i2c-0/0-0034/axp20-supplyer.28/power_supply/ac/current_now" )
	v = v * f:read('*number') / 1000000
	f:close()
	srf_tabpwr:SetColor( findgradiancolor(v, cols ) )
	upddata( srf_tabpwr, fdigit, string.format('%3.2f', v) .. ' W')
	dt_pwr:Push( v )
	local min,max = dt_pwr:MinMax()
	upddata( srf_maxtpwr, fsdigit, string.format('%3.2f', max) )
	updgfx( srf_tpwrgfx, dt_pwr, 0 )

	cols = {
		[30] = COL_DIGIT,
		[40] = COL_ORANGE
	}
	f = io.open( "/sys/devices/platform/sunxi-i2c.0/i2c-0/0-0034/temp1_input" )
	v = f:read('*number') / 1000
	f:close()
	srf_ttpmu:SetColor( findgradiancolor(v, cols ) )
	upddata( srf_ttpmu, fsdigit, string.format('%3.1f', v) .. '°C')

	f = io.open( "/sys/devices/platform/sunxi-i2c.0/i2c-0/0-0034/axp20-supplyer.28/power_supply/battery/temp" )
	v = f:read('*number') / 10
	f:close()
	srf_ttbat:SetColor( findgradiancolor(v, cols ) )
	upddata( srf_ttbat, fsdigit, string.format('%3.1f', v) .. '°C')
end

tabtimer,err = SelTimer.create { when=1, interval=5, clockid=SelTimer.ClockModeConst("CLOCK_MONOTONIC"), ifunc=updateTablet}
if err then
	print(err)
	return
end

-- Wait for events
while true do
	ret, err = Selene.WaitFor(tabtimer)

	if type(ret) == 'function' then
		ret()
	end
end
